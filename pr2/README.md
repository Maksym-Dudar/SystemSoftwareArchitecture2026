# Практична робота №1

## Завдання 1
Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

### Опис

Ця програма реалізована на мові C. Вона автоматично визначає розрядність системи.



### Ідея реалізації

Залежно від розрядності системи тип time_t має різний розмір у байтах, що визначає кількість бітів, доступних для зберігання часу, тому програма спочатку визначає цей розмір і переводить його у біти, після чого враховує, що time_t є знаковим цілим типом, де один біт використовується для знаку, а решта для зберігання кількості секунд від початкової епохи Unix, далі обчислюється максимально можливе значення секунд (зарахунок всіх комбінацій 0 і 1 поділених на 2, бо один з бітів відповідає за знак, а ми враховуємо лише додатній час і від цього діднімаєм одну комбінаці нульового знвчення), яке може бути представлене без переповнення, і виводиться результат, що дозволяє визначити максимальну межу часу.



### Приклад роботи
<img width="464" height="90" alt="Знімок екрана 2026-02-19 о 21 13 52" src="https://github.com/user-attachments/assets/2ea1bbcd-17f5-4622-ba2a-c75bc6c83db2" />



### Збірка та запуск

```bash
gcc time_t.c -o time_t 
./time_t
```

---

## Завдання 2
Розгляньте сегменти у виконуваному файлі.
  1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для
  виконуваного файлу, щоб отримати його загальний розмір, і
  запустіть size, щоб отримати розміри сегментів всередині нього.
  2. Додайте оголошення глобального масиву із 1000 int,
  перекомпілюйте й повторіть вимірювання. Зверніть увагу на
  відмінності.
  3.  Тепер додайте початкове значення в оголошення масиву
  (пам’ятайте, що C не змушує вас вказувати значення для кожного
  елемента масиву в ініціалізаторі). Це перемістить масив із сегмента
  BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
  різницю.
  4. Тепер додайте оголошення великого масиву в локальну функцію.
  Оголосіть другий великий локальний масив з ініціалізатором.
  Повторіть вимірювання. Дані розташовуються всередині функцій,
  залишаючись у виконуваному файлі? Яка різниця, якщо масив
  ініціалізований чи ні?
  5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви
  компілюєте для налагодження? Для максимальної оптимізації?

### Опис

Ця програма реалізована на мові C. Вона розроблена для дослідження сегментів в linux.


### Приклад роботи

Пункт 1

<img width="477" height="465" alt="Знімок екрана 2026-02-20 о 13 40 25" src="https://github.com/user-attachments/assets/6c51a1e4-9cf2-4b4d-b4b2-90d2d81c28c1" />

Пункт 2

<img width="464" height="466" alt="Знімок екрана 2026-02-19 о 21 25 40" src="https://github.com/user-attachments/assets/cccf35f9-912a-4616-81c1-6cb4992505c0" />

Пункт 3

<img width="464" height="453" alt="Знімок екрана 2026-02-19 о 21 25 05" src="https://github.com/user-attachments/assets/05dcffe5-e3c3-4133-ad61-a0d83597304b" />

Пункт 4

<img width="459" height="450" alt="Знімок екрана 2026-02-19 о 21 28 24" src="https://github.com/user-attachments/assets/b350140e-f4c4-491a-bc46-7ec391b70e6c" />

Пункт 5

<img width="576" height="459" alt="Знімок екрана 2026-02-20 о 13 07 03" src="https://github.com/user-attachments/assets/37ac2073-8238-4526-9b2a-c1ea6e22644c" />

<img width="479" height="461" alt="Знімок екрана 2026-02-20 о 13 08 01" src="https://github.com/user-attachments/assets/8fa859e2-34a9-47c0-81b1-4786a5f26be0" />


### Висновки до завдання

Під час аналізу сегментів виконуваного файлу на прикладі програми hello.c було встановлено, що неініціалізовані глобальні змінні потрапляють у сегмент BSS, який не займає місця на диску, а лише резервує пам'ять під час запуску. Проте додавання ініціалізації переміщує масив у сегмент Data, що фізично збільшує розмір файлу, оскільки його значення мають зберігатися в ньому безпосередньо. Великі локальні масиви майже не впливають на розміри сегментів даних, оскільки вони розміщуються у стеку під час виконання, а у файлі відображаються лише як додаткові інструкції в сегменті Text. Також було помічено, що компіляція для налагодження з прапорцем -g суттєво збільшує загальний розмір файлу через додавання службових метаданих, які не завантажуються в робочі сегменти пам'яті, тоді як максимальна оптимізація -O3 впливає на текстовий сегмент, переробляючи код для підвищення ефективності. У підсумку підтверджено, що лише сегменти Text і Data зберігаються у виконуваному файлі, тоді як BSS та стек отримують фізичний обсяг пам'яті лише після старту програми.


## Збірка та запуск

**1. Базова компіляція та аналіз розмірів:**
```bash
gcc hello.c -o hello
ls -l hello
size hello
```

**1. Налагодження (Debug) та аналіз розмірів:**
```bash
gcc -g -O0 hello.c -o hello_debug
size hello_debug
ls -l hello_debug
```


**1. Максимальна оптимізація (Release) та аналіз розмірів:**
```bash
gcc -O3 hello.c -o hello_opt
size hello_opt
ls -l hello_opt
```

---

## Завдання 3
Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
```c
  #include &lt;stdio.h&gt;
    int main() {
      int i;
      printf(&quot;The stack top is near %p\n&quot;, &amp;i);
    return 0;
  }
```
Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.
Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

### Опис

Ця програма реалізована на мові C. Вона розроблена для дослідження сегментів і стека в linux.


### Приклад роботи
<img width="467" height="478" alt="Знімок екрана 2026-02-19 о 22 04 25" src="https://github.com/user-attachments/assets/4d4009c6-bb1c-473d-9855-3533f50abfd3" />


### Висновки до завдання

Верхівка стеку знаходиться за адресами типу 0xfff..., що відповідає верхівці віртуального адресного простору користувача. Сегменти даних і тексту знаходяться за значно нижчими адресами 0xbd9... . При виклику функції з великим масивом адреса вершини стає ще меншою, оскільки стек заповнюється зверху вниз.

## Збірка та запуск
```bash
gcc stack.c -o stack
./stack
```

---

## Завдання 4
Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви можете:
  ● Автоматично за допомогою утиліти gstack.
  ● Вручну за допомогою налагоджувача GDB.

### Опис

Ця програма реалізована на мові C. Вона розроблена для дослідження стека в linux.

### Приклад роботи

<img width="1075" height="313" alt="Знімок екрана 2026-02-19 о 22 52 53" src="https://github.com/user-attachments/assets/7b05dc73-7b0e-4c0b-9a58-e6566fcc193c" />

<img width="1136" height="334" alt="Знімок екрана 2026-02-19 о 22 58 11" src="https://github.com/user-attachments/assets/5ea8b595-a81a-4666-ab98-97a6307433a4" />


## Збірка та запуск
```bash
gdb --quiet
```

і потім:

```bash
attach 10207
```

і варіант з автоматичним виводом backtrace:
```bash
sudo sysctl -w kernel.yama.ptrace_scope=0
gdb -p 10207 -batch -ex bt
```

## Завдання 5

Відомо, що при виклику процедур і поверненні з них процесор використовує стек.Чи можна в такій схемі обійтися без лічильника команд (IP), використовуючи замість нього вершину стека? Обґрунтуйте свою відповідь та наведіть приклади.

### Відповідь
Повідомлення Gemini
Так, це теоретично можливо. У такій схемі замість окремого регістру IP процесор завжди зчитує адресу наступної команди прямо з вершини стека (TOS). Виконана інструкція просто виштовхується (pop), і наступна автоматично стає доступною для виконання. Прикладом є мова Forth.

## Завдання 6
Створіть програму, що змінює права доступу до сегментів пам’яті (mprotect).

### Опис

Ця програма реалізована на мові C. Вона змінює права доступу до сегментів пам’яті в linux.

### Приклад роботи

<img width="457" height="163" alt="Знімок екрана 2026-02-19 о 23 16 37" src="https://github.com/user-attachments/assets/840264b5-2910-4606-9bcd-b2e0360d84fe" />

## Збірка та запуск
```bash
gcc task_var_7.c -o task_var_7
./task_var_7
```
